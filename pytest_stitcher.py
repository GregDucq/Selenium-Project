import sys
import os
import re
#import info

# Indicates if the window has been opened and sized.
# NOTE: The window and sizing is dependent on whatever is in the
# first file the stitcher processes
global master_initialized

# The stitcher program goes through every selenium pytest file in a directory and 
# stitches them together into a single selenium pytest file.
#
# It accepts two required arguments, an input directory and an output directory,
# and an optional flag (simply enter "a" after the two required arguments) that
# indicate that the input and output directories are absolute directories.
# NOTE: If the output directory already exists, the master pytest file will be placed
# in it, otherwise, the directory will be created and the file will be placed in that
# directory
#
# argv[1] = input directory
# argv[2] = output directory
# argv[3] = OPTIONAL absolute directory flag

# Main function: Does argument error checking before 
# running main components of the stitcher
def main():
	
	# Throw an error if fewer than two arguments (the input and output directories)
	# or more than three arguments (the input and output directories along with the optional
	# absolute directory flag) are given
	if (len(sys.argv) < 3 or len(sys.argv) > 4):
		print("ERROR: INVALID INPUT. THERE SHOULD BE TWO OR THREE ARGUMENTS GIVEN")	
		return;
		
	# If the absolute flag is given, simply set the input and output directory variables to whatever
	# was given in the arguments
	if len(sys.argv) == 4 and sys.argv[3] == 'a':
		dir = sys.argv[1]
		out = sys.argv[2]
	
	# If the absolute flag is not given, construct the input and output directory variables
	# using os.getcwd()
	else:
		dir = os.getcwd() + "\\" + sys.argv[1]
		out = os.getcwd() + "\\" + sys.argv[2]
	
	# Check if input directory is a valid directory. If not, return an error message.
	if not os.path.isdir(dir):
		print("ERROR: INVALID INPUT. FIRST ARGUMENT MUST BE AN EXISTING DIRECTORY")	
		return;
	
	global master_initialized
	master_initialized = False
	
	# Generate the code for final pytest file
	selenium_file = file_builder(dir, "", 2);
	
	# Create a file and save the code to it
	file_printer(out, selenium_file)

	
# file_builder recursively goes through each file in the provided directory, stitches
# all the labeled pytest files in that directory together, and then recursively repeats
# this process in all the directories that are in the current directory. Any recursively generated
# code then becomes part of an if statement block whose condition is determined by the name of the folder.
# The method then returns the result of combining the files in directory and the code generated by
# recursively going through each directory in the specified directory.
#
#           dir = The directory the method will search for documents to 
#                 stitch together and then directories to recursively repeat this process.
#                 NOTE: it is assumed that dir does not end with a forward slash ("\")
#
# selenium_file = A String value that stores the code for the final master pytest file.
#                 Every line of code that is processed will be added to the end of the String
#
#        indent = An integer representing the number of indents (\t) that should be included 
#                 before each line of code that is added to selenium_file
#            
def file_builder(dir, selenium_file, indent = 0):
	# Creates a list of all the files in dir
	contents = [f for f in os.listdir(dir + "\\") if os.path.isfile(dir + "\\" + f)]
	# Creates a regex value that will match any pytest file with a name that ends with an underscore
	# followed by one or more integers (Ex. name_3.py, file_45.py, pytest_109.py)
	p = re.compile("\_(\d+)\.py$")
	
	# The name of the next file that will be added to selenium_file
	name = None
	# The number of the next file that will be added to selenium_file (i.e. the number following the underscore
	# at the end of the file's name). This is done so that each pytest file in the directory does not have to be 
	# consecutively numbered as long as they are numbered in the right order
	currFileNum = None
	
	# While there are still files in the directory to check
	while len(contents) != 0:
	
		# Initialize values used in loop. x is the current index being checked.
		name = None
		x = 0;
		while x < len(contents):
			
			# Get the name of the file at index x and check if matches the aforementioned pattern
			# assigned to p
			file = contents[x]
			m = p.search(file)
			
			# Ignore the name completely if it does not match the pattern (meaning the file
			# will not become part of the final master pytest file)
			if m == None:
				contents.remove(file)
			
			# If the name of the file matches the pattern, check if it will be the next file
			# to be added directly to selenium_file (i.e. if both file_2 and file_45 are present),
			# this if statement will guarantee that the code in file_2 is added before the code
			# in file_45 is
			elif name == None or int(m.group(1)) < currFileNum:
				name = file
				currFileNum = int(m.group(1))
				x += 1
			
			# If the name matches the pattern but the file is not the next to be stitched, skip it
			# for not.
			else:
				x += 1
		
		# When the next file is found (assuming one is found), add its code to selenium_file
		# and remove it from the list of files in the directory
		if name != None:
			# Adds the code in the next file to selenium_file
			selenium_file += code_grabber((dir + "\\" + name), indent)
			# Removes the file from the list of files to check
			contents.remove(name)
		
	# Get directories and recursively search through them
	directories = [d for d in os.listdir(dir + "\\") if os.path.isdir(dir + "\\" + d)]
	
	for directory in directories:	
		selenium_file += "\t" * indent + if_statement_generator(directory, dir + "\\")
		selenium_file = file_builder(dir + "\\" + directory, selenium_file, indent + 1) + "\n"
		
	return selenium_file

# code_grabber returns the code in the pytest file whose path is passed to it.
#
#   path - The location of the pytest file whose selenium code will be returned.
# indent - The number of indentations that will be added to each line of the code that
#          this function returns

def code_grabber(path, indent = 2):
	global master_initialized
	
	print(master_initialized)
	
	# Initializes the values this function will use.
	# code is the variable that stores the code in the pytest file
	code = ""
	# Creates regex value that will match the function header for the function containing the selenium code
	# (i.e. \t\tdef test_healthWellTest1(self):,\s\s\sdef test_holup(self):)
	p = re.compile("^\s*def\s+test\_.*\(self\):")
	# Opens the selenium pytest file so that it can be read
	reader = open(path, "r")
	
	# Get the first line of the file
	line = reader.readline()
	
	# File there are lines in the pytest file
	while line != "":
		# Check if the line matches the aforementioned pattern. If it does...
		if p.search(line) != None:
			# Get the next line in the file (the code directly after the function header)
			line = reader.readline()
			# Create a new regex value that will match lines of text with zero or more spaces.
			# followed by text that will be captured. The purpose of this is to get rid of any whitespace
			# Before each line of code so that our specified level of indentation can be added to it.
			p = re.compile("^\s*(.*)$")
			
			# Creates regex values that will match lines of text with zero or more spaces
			# followed by the functions and self.driver.get([URL]) and self.driver.set_window_size([dimensions])
			c1 = re.compile("^self\.driver\.get\(.*\)$")
			c2 = re.compile("^self\.driver\.set\_window\_size\(.*\)$")
			
			# Create a regex value that will check for the line self.driver.get and ignore it unless it hs not been added to the final
			# pytest code yet
			# While there are lines of code in the file to read
			while line != "":
				# Match the code against our pattern
				m = p.search(line)
				
				# Get just the text after the leading whiespace in the line of code,
				# check if it should be added, add our own level of indentation to it, 
				# and add this to the code that will be returned
				text = m.group(1)
				
				print(text)
				
				if c1.search(text) != None:
					if not master_initialized:
						code += "\t" * indent + m.group(1) + "\n"
					
				elif c2.search(text) != None:
					if not master_initialized:
						code += "\t" * indent + m.group(1) + "\n"
						master_initialized = True
					
				else:
					code += "\t" * indent + text + "\n"
					
				# Get the next line in the file
				line = reader.readline()
			
			return code
		
		# Otherwise, keep going through the file
		else:
			line = reader.readline()
	
	# Return the collected code
	return code

# if_statement_generator takes a directory name and converts it to the corresponding if statement
#
# text = The directory name which will be converted to an if statement that this function returns
#  dir = The location of the directory. Used for error reporting.
#
def if_statement_generator(text = "", dir = ""):
	# Initialize if statement that will be returned
	if_statement = "if "
	# Begin looping through each character of text
	x = 0
	while x < len(text):
		# If parentheses are encountered, add them directly into if statement
		if text[x] == '(' or text[x] == ')':
			if_statement += text[x]
		
		# If underscore is encountered, prepare to add an "and", "or", or "not" operator
		elif text[x] == '_':
			# Initialize text to be added to if statement
			operator = ""
			
			# Begin process of looping through text
			x += 1
			while x < len(text) and text[x] != '_':
				operator += text[x]
				x += 1
			
			if x == len(text) or (not operator == "and" and not operator == "or" and not operator == "not"):
				print("ERROR! IMPROPERLY FORMATTED CONDITIONAL OPERATOR FOR DIRECTORY " + text + " AT " + dir)
				return None
				
			else:
				if_statement += " " + operator + " "
		
		elif text[x] == '@':
			condition = ""
			underscore_check = 0
			
			while x < len(text) and not (text[x] == ")" or (text[x] == "_" and underscore_check == 2)):
				condition += text[x]
				
				if(text[x] == "_"):
					underscore_check += 1
					
				x += 1
			
			if(x == len(text) and underscore_check != 2):
				print("ERROR! INCOMPLETE CONDITIONAL EXPRESSION FOR DIRECTORY " + text + " AT " + dir)
				print(if_statement)
				print(condition)
				return None
			
			condition = condition.split("_")
			operator = text_to_conditional(condition[1])
			
			print(condition)
			
			if operator == None:
				print("ERROR! IMPROPERLY FORMATTED CONDITIONAL OPERATOR WITHIN CONDITIONAL EXPRESSION FOR DIRECTORY " + text + " AT " + dir)
				return None
				
			else:
				if (condition[0])[len(condition[0]) - 1] == '$':
					condition[0] = (condition[0])[0:len(condition[0]) - 1]
				
				if_statement += "info[\"" + condition[0] + "\"] " + operator + " " + condition[2]
				if(x < len(text) and text[x] == ")"):
					if_statement += ")"
				
		else:
			print("ERROR! INCOMPLETE IF STATEMENT FOR DIRECTORY " + text + " AT " + dir)
			return None
			
		x += 1
			
	if_statement += ":\n"
	
	return if_statement
			
def text_to_conditional(value = ""):
	print(value)
	if value == 'E':
		return '=='
	elif value == 'NE':
		return '!='
	elif value == 'L':
		return '<'
	elif value == 'LE':
		return '<='
	elif value == 'G':
		return '>'
	elif value == 'GE':
		return '>='
	else:
		return None
	
# file_printer outputs the code passed to it to a file in the directory that is also passed to it.
# 
# dir  = The directory where the file with the code passed to the function will be created
# file = The code that will go in the file that will be created.
def file_printer(dir, file = ""):
	# Create a new directory if the one given does not exist
	if not os.path.isdir(dir):
		os.mkdir(dir)
	
	
	file_header = """import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys

class pytest():
	def setup_method(self, method):
		self.driver = webdriver.Chrome()
		self.vars = {}
  
	def teardown_method(self, method):
		self.driver.quit()

	def test_pytest(self):
"""	

	# Open the file at the directory passed to the function
	out = open(dir + "\\pytest.py", "w")
	
	# Store the code in that directory
	out.write(file_header + file)
	
# Python boiler plate. At runtime, calls the main() function
if __name__ == "__main__":
	main()
